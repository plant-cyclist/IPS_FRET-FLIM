### IPS Extraction Script

### Author:         Leander Rohr, ZMBP TÃ¼bingen

### Purpose:        Calculates the proportion of interacting pixels (IPS) based on a threshold value that was calculated before in Script 2.
###                 (e.g., 10 % FRET Efficiency)
###                 Additionally, upper and lower limits of lifetimes can be set. Please use same values as before in Script 2. 

### License:        [GPL-3.0 license]

### Last Updated:   [2024-12-05]


### Description:
###     - Place all .csv files that were generated by Script 1 and belong to the same group in a single folder.
###     - Set the path to the folder (see line 42)
###     - The script processes each .csv file and filters out values according to the set limits (Set limits in line 55 and 56)
###     - Based on the remaining values, the script counts the number of IPS based on the threshold_IPS value from Script 2 
###         (e.g., 10 % FRET Efficiency) and also calculates their proportion (Set the threshold_IPS value in line 54)
###     - Results are saved in a result.csv file.
###     - If required, missing dependencies are installed automatically.




# Remove all objects in the workspace
rm(list = ls())

# Ensure that all needed packages are installed and loaded
ensure_packages <- function(pkgs) {
  for (pkg in pkgs) {
    if (!requireNamespace(pkg, quietly = TRUE)) {
      install.packages(pkg, dependencies = TRUE)
    }
    library(pkg, character.only = TRUE)
  }
}
ensure_packages ("dplyr")

# Set the working directory and path. This should be the folder where all your .csv files from Script 1 are stored. 
# Please note that R only accepts "/" as slash
path <- "INSERT/FILE/PATH/HERE"
setwd(path)

# List all CSV files in the directory
file_list <- list.files(path, pattern = "*.csv", full.names = TRUE)

# Initialize an empty list to store results
results_list <- list()

# Define the threshold_IPS value (calculated in Script 2) as well as the lower and upper limit for lifetimes.
# threshold_IPS was calculated before in Script 2.
# Please use the same lower and upper limits for lifetimes as in Script 2. 
threshold_IPS <- 2.1095
lower_limit <- 1.5
upper_limit <- 2.7

# Loop through each file
for (file in file_list) {
  # Read the CSV file with comma as decimal separator
  data <- read.csv(file, header = TRUE, dec = ",")
  
  # Check the first few rows and column types of each file
  print(paste("Processing file:", basename(file)))
  print(head(data))
  print(str(data))  # Check structure to confirm column types
  
  # Convert character columns to numeric where possible, ignoring any coercion warnings
  numeric_data <- data %>%
    mutate(across(where(is.character), ~ suppressWarnings(as.numeric(.x)))) %>%
    select(where(~ sum(!is.na(.x)) > 0))  # Retain columns with valid numeric values
  
  # Filter out values outside the specified range [1.5, 2.7]
  numeric_data <- numeric_data %>%
    mutate(across(everything(), ~ ifelse(.x < lower_limit | .x > upper_limit, NA, .x)))
  
  # Calculate the count of values below the threshold and total non-NA values
  counts <- numeric_data %>%
    summarise(across(everything(), list(
      count_below_threshold = ~ sum(.x < threshold_IPS, na.rm = TRUE),
      n_total = ~ sum(!is.na(.x))
    ))) 
  
  # Add file name to the results
  counts <- counts %>% mutate(file_name = basename(file))
  
  # Check for any count and total columns dynamically and calculate percentage
  count_cols <- grep("_count_below_threshold$", names(counts), value = TRUE)
  total_cols <- sub("_count_below_threshold$", "_n_total", count_cols)
  
  for (i in 1:length(count_cols)) {
    count_col <- count_cols[i]
    total_col <- total_cols[i]
    
    if (count_col %in% names(counts) && total_col %in% names(counts) && counts[[total_col]] > 0) {
      counts <- counts %>%
        mutate(percentage_below_threshold = (counts[[count_col]] / counts[[total_col]]) * 100)
    } else {
      counts <- counts %>%
        mutate(percentage_below_threshold = NA)  # Assign NA if condition is not met
    }
  }
  
  # Append to the results list
  results_list[[file]] <- counts
}

# Combine all results into a single data frame
final_results <- bind_rows(results_list)

# Save the final results as a CSV file
write.csv(final_results, file = "result.csv", row.names = FALSE)

# View the results
print(final_results)
